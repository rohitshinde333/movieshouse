from flask import Flask, jsonify, request, redirect, send_file
from flask_cors import CORS, cross_origin
from flask_restful import Resource,Api, marshal_with,reqparse,fields,marshal
import os, csv
from flask_mail import Mail, Message
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required,current_user
from flask import jsonify
from flask_bcrypt import Bcrypt
from werkzeug.security import check_password_hash
app = Flask(__name__)
app.config.from_object(__name__)
basedir = os.path.abspath(os.path.dirname(__file__))
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import or_
from sqlalchemy import extract
from flask_jwt_extended import jwt_required, create_access_token, get_jwt_identity,JWTManager
import json
from flask import make_response
from functools import wraps
from flask import abort
import requests
import pymysql

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'database.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True
app.config['SECRET_KEY']='bin@9'
api = Api(app)
db = SQLAlchemy(app)
jwt = JWTManager(app)
from dateutil import parser as date_parser
app.config["MAIL_SERVER"] = "smtp.gmail.com"
app.config["MAIL_PORT"] = 465
app.config["MAIL_USE_SSL"] = True
app.config["MAIL_USE_TSL"] = False
app.config["MAIL_USERNAME"] = 'rvshinde333@gmail.com'
app.config["MAIL_PASSWORD"] = 'bljsbckjdltxdhre'
mail = Mail(app)
from datetime import datetime
from celery import Celery
from celery.schedules import crontab, timedelta
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Spacer
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Spacer
from reportlab.lib import colors
from reportlab.pdfgen import canvas
from reportlab.platypus import Paragraph
from reportlab.lib.styles import getSampleStyleSheet
import redis
redis_client = redis.StrictRedis(host='localhost', port=6379, decode_responses=True)
def make_celery(app):
    celery = Celery(
        app.import_name,
        backend=app.config['CELERY_RESULT_BACKEND'],
        broker=app.config['CELERY_BROKER_URL']
    )
    

    class ContextTask(celery.Task):
        def __call__(self, *args, **kwargs):
            with app.app_context():
                return self.run(*args, **kwargs)

    celery.Task = ContextTask
    return celery

app.config.update(
    CELERY_BROKER_URL='redis://localhost:6379',
    CELERY_RESULT_BACKEND='redis://localhost:6379'
)

celery = make_celery(app)
@celery.task
def send_reminders():
    cutoff_time = datetime.now() - timedelta(days=1)  
    users_to_remind = User.query.filter(User.last_login < cutoff_time).all()

    for user in users_to_remind:
        subject = "Daily Reminder"
        body = "Dear {}, don't forget to visit/book today!".format(user.name)

           
        email_data = {
                "recipient": user.email,
                "subject": subject,
                "body": body
            }
        response = requests.post("http://localhost:5000/email", json=email_data)

        if response.status_code == 200:
            print("Reminder email sent to", user.name)
        else:
            print("Failed to send reminder email to", user.name)
    
@celery.task
def email_report():
    users = User.query.all()
    today = datetime.today()
    last_month_end = today.replace(day=1) - timedelta(days=1)
    last_month_start = last_month_end.replace(day=1)
    for user in users:
        
        
        user_seatbookings = SeatBooking.query.filter(
            SeatBooking.user_id == user.id,
            
        ).all()
        
        
        user_reviews = Review.query.filter_by(user_id = user.name).all()

        now_formatted = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        path = f'Userreports/report_{user.name}_{now_formatted}.pdf'
        
        doc = SimpleDocTemplate(path, pagesize=letter)
        elements = []
        title_style = getSampleStyleSheet()["Title"]
        title = Paragraph("MoviesHouse Report", title_style)
        elements.append(title)

        
        intro_style = getSampleStyleSheet()["Normal"]
        intro_text = "This is autogenerated pdf. Everything is official here. Thank you for participation."
        intro_paragraph = Paragraph(intro_text, intro_style)
        elements.append(intro_paragraph)

        elements.append(Spacer(1, 20))
        review_data = [["Review ID", "Content", "Likes"]]

        for review in user_reviews:
            review_data.append([review.id, review.content, review.likes])

        review_table = Table(review_data)
        review_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))

        elements.append(review_table)
        elements.append(Spacer(1, 30)) 

        booking_data = [["Show ID", "Movie", "Theater", "Date"]]
        
        for booking in user_seatbookings:
            booking_data.append([booking.showtime.id, booking.showtime.movie.title, booking.showtime.theater.name, booking.showtime.show_datetime])

        booking_table = Table(booking_data)
        booking_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.white),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))

        elements.append(booking_table)
        elements.append(Spacer(1, 30))  

        doc.build(elements)
        
        message = Message("Your Activity Report", recipients=[user.email], sender='rvshinde333@gmail.com')
        message.body = "Please find your activity report attached. This is an autogenerated email. Please don't reply"
        
        with open(path, "rb") as pdf_file:
            message.attach(f"report_{user.name}_{now_formatted}.pdf", "application/pdf", pdf_file.read())
        
        mail.send(message)
        
        os.remove(path)

@celery.task
def export_theatre_report(theatre_id):
    theatre = Theater.query.get(theatre_id)
    shows = theatre.showtimes
    price_p = 0
    
    for show in shows:
        price_p = price_p + show.price
        
    avg_p= price_p/len(shows)
    csv_data = [
        ['Theatre Name', 'Location','City', 'Number of Shows', 'Average Price'],
        
    ]
    
    csv_data.append([theatre.name, theatre.address, theatre.city, len(shows), avg_p])

    
    csv_file_path = f'csv_files/theatre_{theatre_id}_details.csv'
    with open(csv_file_path, 'w', newline='') as csv_file:
        writer = csv.writer(csv_file)
        writer.writerows(csv_data)
    filename = f'theatre_{theatre_id}_details.csv'
    return filename

celery.conf.beat_schedule = {
    'send-daily-reminders': {
        'task': 'main.send_reminders',
        'schedule': crontab(hour=17, minute=0) ,    
    },
    'send-monthly-report': {
        'task': 'main.email_report',
        'schedule': crontab(day_of_month='1', hour='0', minute='0'),    
    },
}
def admin_required(func):
    @wraps(func)
    def decorated(*args, **kwargs):
        if not current_user or not current_user.is_authenticated or not current_user.is_admin:
            return jsonify(message="You don't have the necessary permissions to access this resource."), 403
        return func(*args, **kwargs)
    return decorated




CORS(app, supports_credentials=True, expose_headers='Authorization')
app.config['CORS_HEADERS'] = 'Content-Type'


login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view="login"


bcrypt = Bcrypt(app)


likes = db.Table(
    'likes',
    db.Column('user_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),
    db.Column('review_id',db.Integer, db.ForeignKey('reviews.id'), primary_key=True)
)
# User model
class User(db.Model, UserMixin):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    password = db.Column(db.String(100))
    email = db.Column(db.String(100), unique=True)
    phone = db.Column(db.String(20))
    address = db.Column(db.String(200))
    is_admin = db.Column(db.Boolean, default=False)
    is_theater_admin = db.Column(db.Boolean, default=False)
    theater_id = db.Column(db.Integer, db.ForeignKey('theaters.id', ondelete='SET NULL'), nullable=True)  
    last_login = db.Column(db.DateTime)
    def __init__(self, name, password, email, phone, address, is_admin):
            self.name = name
            self.password = password
            self.email = email
            self.phone = phone
            self.address = address
            self.is_admin = is_admin
# Cast-Movie asscociation
cast_movie_association = db.Table(
    'cast_movie_association',
    db.Column('cast_id', db.Integer, db.ForeignKey('cast.id'), primary_key=True),
    db.Column('movie_id', db.Integer, db.ForeignKey('movie.id'), primary_key=True)
)
# Movie model
class Movie(db.Model):
    __tablename__ = 'movie'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
    genre = db.Column(db.String(100))
    director = db.Column(db.String(100))
    release_date = db.Column(db.Date)
    duration = db.Column(db.Integer)
    description = db.Column(db.String(1000))
    image = db.Column(db.String(1000))
    def __init__(self, title, genre, director, release_date, duration, description, image):
        self.title = title
        self.genre = genre
        self.director = director
        self.release_date = release_date
        self.duration = duration
        self.description = description
        self.image = image

    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'genre': self.genre,
            'director': self.director,
            'release_date': self.release_date.isoformat(),
            'duration': self.duration,
            'description':self.description,
            'image': self.image
            
        }


# Review model
class Review(db.Model):
    __tablename__ = 'reviews'
    
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.String(200), nullable=False)
    likes = db.Column(db.Integer, default=0)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    movie_id = db.Column(db.Integer, db.ForeignKey('movie.id'), nullable=False)
    created_at = db.Column(db.DateTime)
    liked_by = db.relationship('User', secondary='likes',backref=db.backref('liked_reviews', lazy='dynamic'))

    def __init__(self, content, user_id, movie_id, created_at):
        self.content = content
        self.user_id = user_id
        self.movie_id = movie_id
        self.created_at = created_at

    def to_dict(self):
        liked_by_user_ids = [user.id for user in self.liked_by]
        return {
            'id': self.id,
            'content': self.content,
            'likes': self.likes,
            'user_id': self.user_id,
            'movie_id': self.movie_id,
            'liked_by': liked_by_user_ids
            
        }
    
# Cast model
class Cast(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    about = db.Column(db.String(100), nullable=False)
    movies = db.relationship('Movie', secondary=cast_movie_association, backref='casts')
    
    def __init__(self, name, about):
        self.name = name
        self.about = about
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'about': self.about
            # Add other JSON serializable fields here
        }
    
# Theater model
class Theater(db.Model):
    __tablename__ = 'theaters'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    address = db.Column(db.String(200))
    city = db.Column(db.String(100))
    state = db.Column(db.String(100))
    country = db.Column(db.String(100))
    capacity = db.Column(db.Integer)
    
    def __init__(self, name, address, city, state, country, capacity):
        self.name = name
        self.address = address
        self.city = city
        self.state = state
        self.country = country
        self.capacity = capacity
    
    def to_dict(self):
        return{
            'id': self.id,
            'name': self.name,
            'city': self.city,
            'state': self.state,
            'country': self.country,
            'capacity': self.capacity,
            'address': self.address,
        }

# Showtime model
class Showtime(db.Model):
    __tablename__ = 'showtimes'
    
    id = db.Column(db.Integer, primary_key=True)
    movie_id = db.Column(db.Integer, db.ForeignKey('movie.id'))
    theater_id = db.Column(db.Integer, db.ForeignKey('theaters.id'))
    show_datetime = db.Column(db.DateTime)
    available_seats = db.Column(db.Integer)
    price = db.Column(db.Float)
    
    movie = db.relationship('Movie', backref=db.backref('showtimes', lazy=True))
    theater = db.relationship('Theater', backref=db.backref('showtimes', lazy=True))
    
    def __init__(self, movie_id, theater_id, show_datetime, available_seats, price):
        self.movie_id = movie_id
        self.theater_id = theater_id
        self.show_datetime = show_datetime
        self.available_seats = available_seats
        self.price = price
        
    def to_dict(self):
            return {
                'id': self.id,
                'movie_id': self.movie_id,
                'theater_id': self.theater_id,
                'show_datetime': self.show_datetime.isoformat(),  # Convert to ISO 8601 format for JSON compatibility
                'available_seats': self.available_seats,
                'price': self.price,
                'movie': self.movie.to_dict(),  # Convert related Movie object to dictionary using its to_dict method
                'theater': self.theater.to_dict(),  # Convert related Theater object to dictionary using its to_dict method
            }

# Seat model
class SeatBooking(db.Model):
    __tablename__ = 'seatbookings'

    id = db.Column(db.Integer, primary_key=True)
    showtime_id = db.Column(db.Integer, db.ForeignKey('showtimes.id'), nullable=False)
    seat_number = db.Column(db.Integer, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    booking_datetime = db.Column(db.DateTime)

    user = db.relationship('User', backref=db.backref('bookings', lazy=True))
    showtime = db.relationship('Showtime', backref=db.backref('bookings', lazy=True))
    
    def __init__(self, showtime_id, seat_number, user_id, booking_datetime):
        self.showtime_id = showtime_id
        self.seat_number = seat_number
        self.user_id = user_id
        self.booking_datetime = booking_datetime

    def to_dict(self):
            return {
                'id': self.id,
                'showtime_id': self.showtime_id,
                'seat_number': self.seat_number,
                'booking_datetime': self.booking_datetime.isoformat(),  # Convert to ISO 8601 format for JSON compatibility
                'user_id': self.user_id,
                'showtime': self.showtime.to_dict(),  # Convert related Movie object to dictionary using its to_dict method
                 
            }


# Payment model
class Payment(db.Model):
    __tablename__ = 'payments'
    
    id = db.Column(db.Integer, primary_key=True)
    booking_id = db.Column(db.Integer, db.ForeignKey('seatbookings.id'), nullable=False)
    amount = db.Column(db.Float)
    payment_datetime = db.Column(db.DateTime)
    payment_method = db.Column(db.String(100))
    transaction_id = db.Column(db.String(100))
    
    booking = db.relationship('SeatBooking', backref=db.backref('payment', uselist=False))
    
    def __init__(self, booking_id, amount, payment_datetime, payment_method, transaction_id):
        self.booking_id = booking_id
        self.amount = amount
        self.payment_datetime = payment_datetime
        self.payment_method = payment_method
        self.transaction_id = transaction_id



    
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

@app.route('/email', methods=['POST', 'OPTIONS'])
def send_email():
    if request.method == "OPTIONS":
        # Handle CORS preflight request
        response_headers = {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "POST",
            "Access-Control-Allow-Headers": "Content-Type",
        }
        return "", 204, response_headers

    # Handle actual POST request to send email
    data = request.get_json()
    recipient = data.get("recipient")
    subject = data.get("subject")
    body = data.get("body")

    # Create a Flask-Mail message
    msg = Message(subject, recipients=[recipient], sender='no-reply@demo.com')
    msg.body = body

    # Send the message
    mail.send(msg)

    return jsonify({"message": "Email sent"}), 200

@app.route('/movie/<int:movie_id>/reviews', methods=['OPTIONS'])
@cross_origin()
def handle_options_request(movie_id):
    return '', 200


with app.app_context():
    # User resource
    
    user_fields = {
        'id': fields.Integer,
        'name': fields.String,
        'password': fields.String,
        'email': fields.String,
        'phone': fields.String,
        'address': fields.String,
        'is_admin': fields.Boolean
    }

    # Movie resource
    movie_fields = { 
        'id': fields.Integer,
        'title': fields.String,
        'genre': fields.String,
        'director': fields.String,
        'release_date': fields.DateTime(dt_format='iso8601'),
        'duration': fields.Integer,
        'description': fields.String,
        'image': fields.String,
    }

    # Theater resource
    theater_fields = {
        'id': fields.Integer,
        'name': fields.String,
        'address': fields.String,
        'city': fields.String,
        'state': fields.String,
        'country': fields.String,
        'capacity': fields.Integer
    }

    # Showtime resource
    showtime_fields = {
        'id': fields.Integer,
        'movie_id': fields.Integer,
        'theater_id': fields.Integer,
        'show_datetime': fields.DateTime(dt_format='iso8601'),
        'available_seats': fields.Integer,
        'price': fields.Float
    }

    # Booking resource
    booking_fields = {
        'id': fields.Integer,
        'user_id': fields.Integer,
        'showtime_id': fields.Integer,
        'booking_datetime': fields.DateTime(dt_format='iso8601'),
        'num_seats': fields.Integer
    }
    # Review resource
    review_fields = {
    'id': fields.Integer,
    'content': fields.String,
    'likes': fields.Integer,
    'user_id': fields.String,
    'movie_id': fields.Integer
    # Add other fields as needed
}

    # Payment resource
    payment_fields = {
        'id': fields.Integer,
        'booking_id': fields.Integer,
        'amount': fields.Float,
        'payment_datetime': fields.String,
        'payment_method': fields.String,
        'transaction_id': fields.String
    }

    

    # Cast resource
    cast_fields = {
        'id': fields.Integer,
        'name': fields.String,
        'about': fields.String
    }

    show_fields_1 = {
    'id': fields.Integer,
    'movie': fields.String(attribute=lambda show: show.movie.title),  # Access the movie name through the relationship
    'show_datetime': fields.DateTime(dt_format='iso8601'),
    'available_seats': fields.Integer,
    'price': fields.Float
    }
    
    show_fields_2 = {
        'id': fields.Integer,
        'movie_id': fields.Integer,
        'theater_id': fields.Integer,
        'show_datetime': fields.DateTime(dt_format='iso8601'),  # Assuming show_datetime is a DateTime field
        'available_seats': fields.Integer,
        'price': fields.Float,
    }
    
    
# User resource
    

        


    class UserResource(Resource):
        
        @marshal_with(user_fields)
        
        def get(self,user_id):
            
            user = User.query.get(user_id)
            if user:
                return {
                    'id': user.id,
                    'password': user.password,
                    'name': user.name,
                    'email': user.email,
                    'phone': user.phone,
                    'address': user.address
                }
            else:
                return {'message': 'User not found'}, 404

        def post(self):
            parser = reqparse.RequestParser()
            parser.add_argument('name', type=str, required=True)
            parser.add_argument('password', type=str, required=True)
            parser.add_argument('email', type=str, required=True)
            parser.add_argument('phone', type=str, required=True)
            parser.add_argument('address', type=str, required=True)
            parser.add_argument('is_admin', type=bool, required=True)
            parser.add_argument('key',type=str)
            args = parser.parse_args()
            hashing_pwd = bcrypt.generate_password_hash(args['password'])
            if args['is_admin'] == True:
                if args['key'] == '720305':
                    user = User(name=args['name'],password=hashing_pwd, email=args['email'], phone=args['phone'], address=args['address'], is_admin=args['is_admin'])
                    db.session.add(user)
                    db.session.commit()
                    return {'message': 'User created successfully'}, 201
                else:
                    return {'message': 'You do not have propery access Key'}
            else:
                user = User(name=args['name'],password=hashing_pwd, email=args['email'], phone=args['phone'], address=args['address'], is_admin=args['is_admin'])
                db.session.add(user)
                db.session.commit()
            return {'message': 'User created successfully'}, 201
        
        @jwt_required()
        def put(self, user_id):
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next((user for user in users if user.name == current_user), None)
            # Access protected resource for the authenticated user
            if user :
                parser = reqparse.RequestParser()
                parser.add_argument('name', type=str)
                parser.add_argument('email', type=str)
                parser.add_argument('phone', type=str)
                parser.add_argument('address', type=str)
                parser.add_argument('is_admin', type=bool)
                args = parser.parse_args()

                user = User.query.get(user_id)
                if not user:
                    return {'message': 'User not found'}, 404

                if args['name']:
                    user.name = args['name']
                if args['email']:
                    user.email = args['email']
                if args['phone']:
                    user.phone = args['phone']
                if args['address']:
                    user.address = args['address']
                if args['is_admin']:
                    user.is_admin = args['is_admin']

                db.session.commit()

                return {'message': 'User updated successfully'}, 200
        @jwt_required()
        def delete(self):
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next((user for user in users if user.name == current_user), None)
            
            if user:
                showsBooked = SeatBooking.query.filter_by(user_id = user.id)
                for show in showsBooked:
                    db.session.delete(show)
                    db.session.commit()
                reviews = Review.query.filter_by(user_id = user.id)
                for review in reviews:
                    db.session.delete(review)
                    db.session.commit()
                db.session.delete(user)
                db.session.commit()
                return {'message': 'User deleted successfully'}, 200
            else:
                return {'message': 'User not found'}, 404

    # Login resource
    class LoginResource(Resource):
        def post(self):
            parser = reqparse.RequestParser()
            parser.add_argument('name', type=str, required=True)
            parser.add_argument('password', type=str, required=True)
            args = parser.parse_args()

            username = args['name']
            password = args['password']
            
            # Retrieve the user from the database based on the provided username
            user = User.query.filter_by(name=username).first()

            if user and bcrypt.check_password_hash(user.password, password):
                user.last_login = datetime.now()
                db.session.commit()
                access_token = create_access_token(identity=user.name)
                return {'access_token': access_token, 'is_admin': user.is_admin,'is_theatre_admin': user.is_theater_admin, 'theatre_id': user.theater_id}, 200
            else:
                return {'message': 'Invalid username or password'}, 401
            
    class ProtectedResource(Resource):
        @jwt_required()
        def get(self):
            # Retrieve the current user from the access token
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next((user for user in users if user.name == current_user), None)
            # Access protected resource for the authenticated user
            if user and user.is_admin == True:
                return jsonify({'message': 'Welcome, admin! You have access to protected resource','name':  current_user,'id': user.id})
            else:
                return jsonify({'message': 'Welcome, user! You have access to protected resource','name':  current_user,'id': user.id})
            
    class MovieIndResource(Resource):
        @marshal_with(movie_fields)
        def get(self,movie_id):
            movie = Movie.query.get(movie_id)
            movie_data = {
                    'id': movie.id,
                    'title': movie.title,
                    'genre': movie.genre,
                    'director': movie.director,
                    'release_date': movie.release_date,
                    'duration': movie.duration,
                    'description': movie.description,
                    'image': movie.image
                }
            return movie_data
    
    
        
    # Movie resource
    class MovieResource(Resource):
        
        @marshal_with(movie_fields)
        def get(self):
            movies = Movie.query.all()
              # Retrieve all movies from the database
            movie_list = []
            for movie in movies:
                movie_data = {
                    'id': movie.id,
                    'title': movie.title,
                    'genre': movie.genre,
                    'director': movie.director,
                    'release_date': movie.release_date,
                    'duration': movie.duration,
                    'description': movie.description,
                    'image': movie.image
                }
                movie_list.append(movie_data)
            
            return movie_list
        @jwt_required()
        def post(self):
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next((user for user in users if user.name == current_user), None)
            
            if user and user.is_admin:
                parser = reqparse.RequestParser()
                parser.add_argument('title', type=str, required=True)
                parser.add_argument('genre', type=str, required=True)
                parser.add_argument('director', type=str, required=True)
                parser.add_argument('release_date', type=str, required=True)
                parser.add_argument('duration', type=int, required=True)
                parser.add_argument('description', type=str, required=True)
                parser.add_argument('image', type=str, required=True)
                parser.add_argument('cast_ids', type=int, action='append', required=True)
                args = parser.parse_args()
                
                release_date_str = args['release_date']
                release_date = datetime.strptime(release_date_str, '%Y-%m-%d').date()
                
                cast_ids = args['cast_ids']
                
                movie = Movie(
                    title=args['title'],
                    genre=args['genre'],
                    director=args['director'],
                    release_date=release_date,
                    duration=args['duration'],
                    description=args['description'],
                    image=args['image']
                )
                
                for cast_id in cast_ids:
                    cast = Cast.query.get(cast_id)
                    if cast:
                        movie.casts.append(cast)
                
                db.session.add(movie)
                db.session.commit()
                
                return {'message': 'Movie created successfully'}, 201
            else:
                return {'message': 'Movie creation failed'}, 500

        @jwt_required()
        def put(self, movie_id):
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next((user for user in users if user.name == current_user), None)
            # Access protected resource for the authenticated user
            if user and user.is_admin == True:
                parser = reqparse.RequestParser()
                parser.add_argument('title', type=str)
                parser.add_argument('genre', type=str)
                parser.add_argument('director', type=str)
                parser.add_argument('release_date', type=str)
                parser.add_argument('duration', type=int)
                parser.add_argument('description', type=str)
                parser.add_argument('image', type=str)
                args = parser.parse_args()
                
                movie = Movie.query.get(movie_id)
                if not movie:
                    return {'message': 'Movie not found'}, 404

                if args['title']:
                    movie.title = args['title']
                if args['genre']:
                    movie.genre = args['genre']
                if args['director']:
                    movie.director = args['director']
                
                if args['release_date']:
                    release_date_str = args['release_date']
                    release_date = datetime.strptime(release_date_str, '%Y-%m-%d').date()
                    movie.release_date = release_date
                    
                if args['duration']:
                    movie.duration = args['duration']
                if args['description']:
                    movie.description = args['description']
                if args['image']:
                    movie.description = args['image']

                db.session.commit()

                return {'message': 'Movie updated successfully', 'movie': {
                    'id': movie.id,
                    'title': movie.title,
                    'genre': movie.genre,
                    'director': movie.director,
                    'release_date': str(movie.release_date),
                    'duration': movie.duration,
                    'description': movie.description,
                    'image': movie.image
                }}, 200
            else:
                return {'message':'something wrong with authentication'}
            
        @jwt_required()
        def delete(self, movie_id):
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next((user for user in users if user.name == current_user), None)
            # Access protected resource for the authenticated user
            if user and user.is_admin:
                movie = Movie.query.get(movie_id)
                if movie:
                    shows = Showtime.query.filter_by(movie_id = movie_id)
                    if shows:
                        for show in shows:
                            bookings = SeatBooking.query.filter_by(showtime_id = show.id)
                            for booking in bookings:
                                db.session.delete(booking)
                                db.session.commit()
                            db.session.delete(show)
                            db.session.commit()
                    db.session.delete(movie)
                    db.session.commit()
                    return {'message': 'Movie deleted successfully'}, 200
                else:
                    return {'message': 'Movie not found'}, 404

    # Review resource
    
    class ReviewResource(Resource):
        def __init__(self):
            self.parser = reqparse.RequestParser()
            self.parser.add_argument('content', type=str, required=True)
            super(ReviewResource, self).__init__()

        @marshal_with(review_fields)
        def get(self, movie_id):
            if movie_id is None:
                return {'message': 'Movie ID not provided'}, 400
            reviews = Review.query.filter_by(movie_id=movie_id).order_by(Review.likes.desc()).limit(6).all()
            return reviews, 200

        @jwt_required()
        def post(self, movie_id):
            current_user_id = get_jwt_identity()
            data = request.get_json()
            content = data.get('content')
            created_at = datetime.now()
            if not content:
                return {'message': 'Missing required data'}, 400

            # Create a new review with the user ID from the JWT token
            review = Review(content=content, user_id=current_user_id, movie_id=movie_id, created_at=created_at)
            db.session.add(review)
            db.session.commit()

            return {'message': 'Review created successfully', 'review_id': review.id}, 201

        @jwt_required()
        def put(self, movie_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()

            if not user:
                return {'message': 'User not found'}, 404

            movie = Movie.query.get(movie_id)

            if not movie:
                return {'message': 'Movie not found'}, 404

            args = self.parser.parse_args()
            review_id = args['id']  # Use 'id' instead of 'review_id'
            content = args['content']

            if not review_id or not content:
                return {'message': 'Missing required data'}, 400

            review = Review.query.get(review_id)

            if not review:
                return {'message': 'Review not found'}, 404

            if review.user_id != user.id:
                return {'message': 'Unauthorized access'}, 403

            review.content = content
            db.session.commit()

            return {'message': 'Review updated successfully', 'review': review.to_dict()}, 200

        @jwt_required()
        def delete(self, movie_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()

            if not user:
                return {'message': 'User not found'}, 404

            movie = Movie.query.get(movie_id)

            if not movie:
                return {'message': 'Movie not found'}, 404

            args = self.parser.parse_args()
            review_id = args['id']  # Use 'id' instead of 'review_id'

            if not review_id:
                return {'message': 'Missing required data'}, 400

            review = Review.query.get(review_id)

            if not review:
                return {'message': 'Review not found'}, 404

            if review.user_id != user.id:
                return {'message': 'Unauthorized access'}, 403

            db.session.delete(review)
            db.session.commit()

            return {'message': 'Review deleted successfully'}, 200

    # Like resource
    class LikeReviewResource(Resource):
        @jwt_required()
        def post(self, movie_id, review_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()

            if not user:
                return {'message': 'User not found'}, 404

            movie = Movie.query.get(movie_id)

            if not movie:
                return {'message': 'Movie not found'}, 404

            review = Review.query.get(review_id)

            if not review:
                return {'message': 'Review not found'}, 404

            if review.user_id == user.id:
                return {'message': 'You cannot like your own review'}, 403

            if user in review.liked_by:
                return {'message': 'You have already liked this review'}, 409

            review.likes += 1
            review.liked_by.append(user)
            db.session.commit()

            return {'message': 'Review liked successfully', 'likes': review.likes}, 201

        @jwt_required()
        def delete(self, movie_id, review_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()

            if not user:
                return {'message': 'User not found'}, 404

            movie = Movie.query.get(movie_id)

            if not movie:
                return {'message': 'Movie not found'}, 404

            review = Review.query.get(review_id)

            if not review:
                return {'message': 'Review not found'}, 404

            if user not in review.liked_by:
                return {'message': 'You have not liked this review'}, 403

            review.likes -= 1
            review.liked_by.remove(user)
            db.session.commit()

            return {'message': 'Review unliked successfully', 'likes': review.likes}, 200



    # Theater resource
    class TheaterResource(Resource):
        @marshal_with(theater_fields)
        def get(self, theater_id=None, secure_key=None):
            if theater_id is None and secure_key is None:
                theaters = Theater.query.all()
                theater_list = []
                for theater in theaters:
                    theater_data = {
                        'id': theater.id,
                        'name': theater.name,
                        'address': theater.address,
                        'city': theater.city,
                        'state': theater.state,
                        'country': theater.country,
                        'capacity': theater.capacity
                    }
                    theater_list.append(theater_data)
                
                return theater_list
            
        
        @jwt_required()
        def post(self, theater_id=None, secure_key=None):
            if theater_id is None and secure_key is None:
                current_user = get_jwt_identity()
                user = User.query.filter_by(name=current_user).first()
                if not user.is_admin :
                    return {'message':'You are not authorized to perform this action.'}
                parser = reqparse.RequestParser()
                parser.add_argument('name', type=str, required=True)
                parser.add_argument('address', type=str, required=True)
                parser.add_argument('city', type=str, required=True)
                parser.add_argument('state', type=str, required=True)
                parser.add_argument('country', type=str, required=True)
                parser.add_argument('capacity', type=int, required=True)
                args = parser.parse_args()

                theater = Theater(
                    name=args['name'],
                    address=args['address'],
                    city=args['city'],
                    state=args['state'],
                    country=args['country'],
                    capacity=args['capacity']
                )

                db.session.add(theater)
                db.session.commit()

                return {'message': 'Theater added successfully', 'theater': theater.to_dict()}, 201
            else:
                if secure_key is None:
                    return {'message': 'Unauthorized. You need admin privileges to perform this action.'}, 403
                current_user = get_jwt_identity()
                user = User.query.filter_by(name=current_user).first()
                

                
                if not user:
                    return {'message': 'User not found.'}, 404

                if secure_key == 720305:
                    user.is_theater_admin = True
                    user.theater_id = theater_id  # Set the theater_id for the user
                    db.session.commit()
                    return {'message': 'Theater admin privileges assigned successfully.'}, 200
                else:
                    return {'message': 'Unauthorized. You need admin privileges to perform this action.'}, 403
                
        
        
        
        @jwt_required()
        def delete(self, theater_id,  secure_key=None):
            
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            if not user.is_admin :
                return {'message':'You are not authorized to perform this action.'}
            theater = Theater.query.get(theater_id)
            if theater:
                shows = Showtime.query.filter_by(theater_id = theater_id )
                for show in shows:
                    bookings = SeatBooking.query.filter_by(showtime_id = show.id)
                    for booking in bookings:
                        db.session.delete(booking)
                        db.session.commit()
                    db.session.delete(show)
                    db.session.commit()
                admin = User.query.filter_by(theater_id = theater.id)
                admin.is_theater_admin = False
                admin.theater_id = 0
                db.session.commit()
                db.session.delete(theater)
                db.session.commit()
                return {'message': 'Theater deleted successfully'}, 200
            else:
                return {'message': 'Theater not found'}, 404


    # Showtime resource
    class ShowtimeResource(Resource):
        @marshal_with(showtime_fields)
        def get(self, showtime_id):
            showtime = Showtime.query.get(showtime_id)
            if showtime:
                return {
                    'id': showtime.id,
                    'movie_id': showtime.movie_id,
                    'theater_id': showtime.theater_id,
                    'show_datetime': showtime.show_datetime.isoformat(),
                    'available_seats': showtime.available_seats,
                    'price': showtime.price
                }
            else:
                return {'message': 'Showtime not found'}, 404
        @jwt_required()
        def post(self):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            if not user.is_theater_admin:
                return {'message': 'Unauthorized. You need theater admin privileges to perform this action.'}, 403
            parser = reqparse.RequestParser()
            parser.add_argument('movie_id', type=int, required=True)
            parser.add_argument('theater_id', type=int, required=True)
            parser.add_argument('show_datetime', type=str, required=True)
            parser.add_argument('available_seats', type=int)
            parser.add_argument('price', type=float, required=True)
            args = parser.parse_args()
            try:
                show_datetime = date_parser.parse(args['show_datetime'])
            except ValueError:
                return {'message': 'Invalid show_datetime format. Use ISO 8601 format: YYYY-MM-DDTHH:mm:ss'}, 400
            showtime = Showtime(movie_id=args['movie_id'], theater_id=args['theater_id'],
                                show_datetime=show_datetime, available_seats=args['available_seats'],
                                price=args['price'])
            db.session.add(showtime)
            db.session.commit()

            return {'message': 'Showtime created successfully'}, 201

        @jwt_required()
        def put(self, showtime_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            if not user.is_admin :
                return {'message':'You are not authorized to perform this action.'}
            parser = reqparse.RequestParser()
            parser.add_argument('movie_id', type=int)
            parser.add_argument('theater_id', type=int)
            parser.add_argument('show_datetime', type=str)
            parser.add_argument('available_seats', type=int)
            parser.add_argument('price', type=float)
            args = parser.parse_args()

            showtime = Showtime.query.get(showtime_id)
            if not showtime:
                return {'message': 'Showtime not found'}, 404
            try:
                show_datetime = date_parser.parse(args['show_datetime'])
            except ValueError:
                return {'message': 'Invalid show_datetime format. Use ISO 8601 format: YYYY-MM-DDTHH:mm:ss'}, 400
            if args['movie_id']:
                showtime.movie_id = args['movie_id']
            if args['theater_id']:
                showtime.theater_id = args['theater_id']
            if args['show_datetime']:
                showtime.show_datetime = show_datetime
            if args['available_seats']:
                showtime.available_seats = args['available_seats']
            if args['price']:
                showtime.price = args['price']

            db.session.commit()

            return {'message': 'Showtime updated successfully'}, 200

        @jwt_required()
        def delete(self, showtime_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            if not user.is_theater_admin :
                return {'message':'You are not authorized to perform this action.'}
            showtime = Showtime.query.get(showtime_id)
            bookings = showtime.bookings
            if bookings:
                for booking in bookings:
                    db.session.delete(booking)
                    db.session.commit()
            if showtime:
                db.session.delete(showtime)
                db.session.commit()
                return {'message': 'Showtime deleted successfully'}, 200
            else:
                return {'message': 'Showtime not found'}, 404

    # Booking resource
    class BookingResource(Resource):
        
        def get(self,booking_id):
            booked_seats = SeatBooking.query.filter_by(showtime_id=booking_id).all()
            
            booked_seat_numbers = [booking.seat_number for booking in booked_seats]
            
            return booked_seat_numbers
                
            
            
        @jwt_required()
        def post(self):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            data = request.get_json()
            showtime_id = data.get('show_id')
            theater_id = data.get('theater_id')
            selected_seats = data.get('selected_seats')
            booking_datetime = datetime.now()
            # Check if the selected seats are available
            theater = Theater.query.get(theater_id)
            theater_capacity = theater.capacity
            booked_seats_for_show = SeatBooking.query.filter_by(showtime_id=showtime_id).all()
            booked_seats_for_show = [booking.seat_number for booking in booked_seats_for_show]

            is_seat_available = all(
                seat not in booked_seats_for_show and seat <= theater_capacity for seat in selected_seats
            )

            if not is_seat_available:
                return {'message':'Selected seats are not available or exceed theater capacity.'}, 400

            # Book the seats in the database
            for seat in selected_seats:
                booking = SeatBooking(showtime_id=showtime_id,seat_number=seat, user_id=user.id, booking_datetime=booking_datetime)
                db.session.add(booking)

            db.session.commit()

            # Return a successful response
            return {'message':'Show booked successfully!'}

        

        @jwt_required()
        def delete(self, booking_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            booking = SeatBooking.query.get(booking_id)

            if booking.user.id == user.id:
                db.session.delete(booking)
                db.session.commit()
                return {'message': 'Booking deleted successfully'}, 200
            else:
                return {'message': 'Booking not found'}, 404

    
    
    # Payment resource
    class PaymentResource(Resource):
        @marshal_with(payment_fields)
        def get(self, payment_id):
            payment = Payment.query.get(payment_id)
            if payment:
                return {
                    'id': payment.id,
                    'booking_id': payment.booking_id,
                    'amount': payment.amount,
                    'payment_datetime': payment.payment_datetime.isoformat(),
                    'payment_method': payment.payment_method,
                    'transaction_id': payment.transaction_id
                }
            else:
                return {'message': 'Payment not found'}, 404

        def post(self):
            parser = reqparse.RequestParser()
            parser.add_argument('booking_id', type=int, required=True)
            parser.add_argument('amount', type=float, required=True)
            parser.add_argument('payment_datetime', type=str, required=True)
            parser.add_argument('payment_method', type=str, required=True)
            parser.add_argument('transaction_id', type=str, required=True)
            args = parser.parse_args()
            booking = SeatBooking.query.get(args['booking_id'])
            if not booking:
                return {'message': 'Booking not found'}, 404
            payment = Payment(booking_id=args['booking_id'], amount=args['amount'],
                            payment_datetime=args['payment_datetime'], payment_method=args['payment_method'],
                            transaction_id=args['transaction_id'])
            db.session.add(payment)
            db.session.commit()

            # Update booking status to 'paid'
            booking.status = 'paid'
            db.session.commit()

            return {'message': 'Payment created successfully'}, 201
        def put(self, payment_id):
            parser = reqparse.RequestParser()
            parser.add_argument('booking_id', type=int)
            parser.add_argument('amount', type=float)
            parser.add_argument('payment_method', type=str)
            args = parser.parse_args()

            payment = Payment.query.get(payment_id)
            if not payment:
                return {'message': 'Payment not found'}, 404

            if args['booking_id']:
                payment.booking_id = args['booking_id']
            if args['amount']:
                payment.amount = args['amount']
            if args['payment_method']:
                payment.payment_method = args['payment_method']

            db.session.commit()

            return {'message': 'Payment updated successfully'}, 200

        def delete(self, payment_id):
            payment = Payment.query.get(payment_id)
            if payment:
                db.session.delete(payment)
                db.session.commit()
                return {'message': 'Payment deleted successfully'}, 200
            else:
                return {'message': 'Payment not found'}, 404
 
    
            
    class CastResource(Resource):
        @marshal_with(cast_fields)
        def get(self, cast_id=None):
            if cast_id:
                
                cast = Cast.query.get(cast_id)
                if cast:
                    return cast.to_dict(), 200
                else:
                    return {'message': 'Cast not found'}, 404
            else:
                casts = Cast.query.all()
                return [cast.to_dict() for cast in casts], 200
                
        @jwt_required()
        def post(self):
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next((user for user in users if user.name == current_user), None)
            if user and user.is_admin:
                parser = reqparse.RequestParser()
                parser.add_argument('name',type=str)
                parser.add_argument('about',type=str)
                args = parser.parse_args()
                cast = Cast(name=args['name'],about=args['about'])
                db.session.add(cast)
                db.session.commit()                
                return {"message":"success"}
            return {"message":"unsuccessfull"}
        
        @jwt_required()
        def put(self, cast_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            if not user.is_admin :
                return {'message':'You are not authorized to perform this action.'}
            data = request.get_json()
            name = data.get('name')
            about = data.get('about')

            if not name or not about:
                return {'message': 'Missing required data'}, 400

            cast = Cast.query.get(cast_id)
            if not cast:
                return {'message': 'Cast not found'}, 404

            cast.name = name
            cast.about = about
            db.session.commit()

            return {'message': 'Cast updated successfully'}, 200

        @jwt_required()
        def delete(self, cast_id):
            current_user = get_jwt_identity()
            user = User.query.filter_by(name=current_user).first()
            if not user.is_admin :
                return {'message':'You are not authorized to perform this action.'}
            cast = Cast.query.get(cast_id)
            if not cast:
                return {'message': 'Cast not found'}, 404
            movies = cast.movies
            for movie in movies:
                db.session.delete(movie)
                db.session.commit()
            db.session.delete(cast)
            db.session.commit()

            return {'message': 'Cast deleted successfully'}, 200
    class TheatreInfoResource(Resource):
        @marshal_with(theater_fields)
        def get(self,theatre_id):
            theater = Theater.query.get(theatre_id)
            if theater:
                return {
                    'id': theater.id,
                    'name': theater.name,
                    'address': theater.address,
                    'city': theater.city,
                    'state': theater.state,
                    'country': theater.country,
                    'capacity': theater.capacity
                }
            else:
                return {'message': 'Theater not found'}, 404
            
    class TheatreShowsResource(Resource):
        @marshal_with(show_fields_1)
        def get(self, theatre_id):
            
            shows = Showtime.query.filter_by(theater_id=theatre_id).all()
            
            for show in shows:
                booked_seats = SeatBooking.query.filter_by(showtime_id=show.id).all()
            
                booked_seat_numbers = [booking.seat_number for booking in booked_seats]
                show.available_seats = len(booked_seat_numbers)
            return shows

    class CurrentUserCityResource(Resource):
        @jwt_required()
        def get(self):
            current_user = get_jwt_identity()
            users = User.query.all()
            user = next(filter(lambda u: u.name == current_user, users), None)
            if user:
                return {'address': user.address, 'email': user.email}
            else:
                return {'message': 'User not found'}, 404

    class ShowsMovieCityResource(Resource):
        def post(self,movie_id,city):
            

            if not movie_id or not city:
                return {"error": "Missing movieId or city in the request payload"}, 400

            filtered_shows = Showtime.query.join(Theater).filter(Showtime.movie_id == movie_id, Theater.city == city).all()

            filtered_shows_dicts = [show.to_dict() for show in filtered_shows]
            
           
            return filtered_shows_dicts

    @app.route('/userBookedShows',methods=['GET'])
    @jwt_required()
    def userBookedShow():
        current_user = get_jwt_identity()
        users = User.query.all()
        user = next(filter(lambda u: u.name == current_user, users), None)
        bookedShows = SeatBooking.query.filter_by(user_id = user.id).all()
        booked_shows_data = []
        for show in bookedShows:

            booked_shows_data.append({
                'id': show.id,
                'seat_number': show.seat_number,
                'booking_datetime': show.booking_datetime.isoformat(),  
                'showtime': show.showtime.to_dict(),  
                 
            })
            
        return booked_shows_data

    @app.route('/check_task_status/<task_id>', methods=['GET'])
    def check_task_status(task_id):
        result = celery.AsyncResult(task_id)
        if result.ready():
            download_url = f'http://localhost:5000/download/{result.result}'
            return jsonify({'status': 'SUCCESS', 'download_url': download_url})
        elif result.state == 'PENDING' or result.state == 'STARTED':
            return jsonify({'status': result.state})
        else:
            return jsonify({'status': 'FAILURE'})
    
    @app.route('/download/<csv_filename>', methods=['GET'])
    def download_csv(csv_filename):
        csv_file_path = f'csv_files/{csv_filename}'
        return send_file(csv_file_path, as_attachment=True)
    
    @app.route('/search')
    def search():
        query = request.args.get('q')
        show_results = perform_show_search(query)
        theater_results = perform_theater_search(query)
        movie_results = perform_movie_search(query)
        

        return jsonify({
        'movies': movie_results,
        'theaters': theater_results,
        'shows': show_results
        })

    def perform_show_search(query):
        show_results = Showtime.query \
            .join(Movie, Showtime.movie_id == Movie.id) \
            .join(Theater, Showtime.theater_id == Theater.id) \
            .filter(
                or_(
                    Showtime.show_datetime.ilike(f'%{query}%'),
                    Movie.title.ilike(f'%{query}%'),
                    Theater.name.ilike(f'%{query}%')
                )
            ) \
            .all()

        # Convert the showtime results to dictionaries using the to_dict method
        show_results_dicts = [show.to_dict() for show in show_results]
        return show_results_dicts

    def perform_theater_search(query):
        theater_results = Theater.query \
            .filter(
                or_(
                    Theater.name.ilike(f'%{query}%'),
                    Theater.city.ilike(f'%{query}%'),
                    Theater.state.ilike(f'%{query}%'),
                    Theater.country.ilike(f'%{query}%'),
                    Theater.address.like(f'%{query}')
                )
            ) \
            .all()

        # Convert the theater results to dictionaries using the to_dict method
        theater_results_dicts = [theater.to_dict() for theater in theater_results]
        return theater_results_dicts

    def perform_movie_search(query):
        movie_results = Movie.query \
            .filter(
                or_(
                    Movie.title.ilike(f'%{query}%'),
                    Movie.genre.ilike(f'%{query}%'),
                    Movie.director.ilike(f'%{query}%')
                )
            ) \
            .all()

        # Convert the movie results to dictionaries using the to_dict method
        movie_results_dicts = [movie.to_dict() for movie in movie_results]
        return movie_results_dicts
    
    @app.route('/generate_report/<int:theatre_id>', methods=['POST'])
    
    def generate_report(theatre_id):
        
        
        task = celery.send_task('main.export_theatre_report', args=[theatre_id])
        
        return jsonify({'message':'You will shortly be able to download csv file','task_id': task.id})

    @app.route('/theaters/<int:theater_id>/<int:secure_key>', methods=['OPTIONS'])
    def handle_options_theatres(theater_id,secure_key):
        response = jsonify({'message': 'Preflight request successful'})
        response.headers.add('Access-Control-Allow-Methods', 'PUT')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        return response

    @app.route('/theaters/<int:theater_id>', methods=['OPTIONS'])
    def handle_options_theatres_(theater_id):
        response = jsonify({'message': 'Preflight request successful'})
        response.headers.add('Access-Control-Allow-Methods', 'PUT')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        return response
    

    @app.route('/movies/<int:movie_id>', methods=['OPTIONS'])
    def handle_options(movie_id):
        response = jsonify({'message': 'Preflight request successful'})
        response.headers.add('Access-Control-Allow-Methods', 'PUT')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        return response
    
    @app.route('/currentUserCity', methods=['OPTIONS'])
    def handle_options_2():
        response = jsonify({'message': 'Preflight request successful'})
        response.headers.add('Access-Control-Allow-Methods', 'PUT')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        return response
    
    @app.route('/showsAtCity/<int:movie_id>/<string:city>', methods=['OPTIONS'])
    def handle_options_3(movie_id,city):
        response = jsonify({'message': 'Preflight request successful'})
        response.headers.add('Access-Control-Allow-Methods', 'PUT')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        return response
    
    @app.route('/movies/<int:movie_id>/reviews/<int:review_id>/like', methods=['OPTIONS'])
    def handle_options_4(movie_id,review_id):
        response = jsonify({'message': 'Preflight request successful'})
        response.headers.add('Access-Control-Allow-Methods', 'PUT')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        return response
    
    @app.route('/addcast/shortcut',methods=['POST'])
    def addCastShortcut():
            try:
                data = request.json
                casts = []

                for cast_info in data:
                    new_cast = Cast(name=cast_info['Name'], about=cast_info['About'])
                    casts.append(new_cast)

                db.session.add_all(casts)
                db.session.commit()

                return jsonify({'success': True, 'message': f'{len(casts)} casts added to the database.'}), 201

            except Exception as e:
                db.session.rollback()
                return jsonify({'success': False, 'message': 'An error occurred.'}), 500
            
    @app.route('/theaterEditing/<int:theater_id>',methods=['PATCH'])
    @jwt_required()
    def patch( theater_id=None):
        current_user = get_jwt_identity()
        user = User.query.filter_by(name=current_user).first()
        if not user.is_admin :
            return {'message':'You are not authorized to perform this action.'}
        parser = reqparse.RequestParser()
        parser.add_argument('name', type=str)
        parser.add_argument('address', type=str)
        parser.add_argument('city', type=str)
        parser.add_argument('state', type=str)
        parser.add_argument('country', type=str)
        parser.add_argument('capacity', type=int)
        args = parser.parse_args()

        theater = Theater.query.get(theater_id)
        if not theater:
            return {'message': 'Theater not found'}, 404

        if args['name']:
            theater.name = args['name']
        if args['address']:
            theater.address = args['address']
        if args['city']:
            theater.city = args['city']
        if args['state']:
            theater.state = args['state']
        if args['country']:
            theater.country = args['country']
        if args['capacity']:
            theater.capacity = args['capacity']

        db.session.commit()

        return {'message': 'Theater updated successfully'}, 200
                 
    
           
        

    
    

    # Define allowed HTTP methods for each resource
    api.add_resource(UserResource, '/users', '/users/<int:user_id>', methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(MovieResource, '/movies', '/movies/<int:movie_id>', methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(TheaterResource, '/theaters', '/theaters/<int:theater_id>/<int:secure_key>', methods=['GET', 'POST', 'PATCH', 'DELETE'])
    api.add_resource(ShowtimeResource, '/showtimes', '/showtimes/<int:showtime_id>', methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(BookingResource, '/bookings', '/bookings/<int:booking_id>', methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(PaymentResource, '/payments', '/payments/<int:payment_id>', methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(LoginResource, '/login',  methods=['POST'],endpoint='login')
    api.add_resource(ProtectedResource, '/protected',methods=['GET'])
    api.add_resource(CastResource, '/casts', '/casts/<int:cast_id>', methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(MovieIndResource, '/movie', '/movie/<int:movie_id>', methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(ReviewResource, '/movie/<int:movie_id>/reviews', endpoint='reviews',methods=['GET', 'POST', 'PUT', 'DELETE'])
    api.add_resource(LikeReviewResource, '/movies/<int:movie_id>/reviews/<int:review_id>/like',methods=['POST','DELETE'])
    api.add_resource(TheatreInfoResource,'/theatre/info/<int:theatre_id>',methods=['GET'])
    api.add_resource(TheatreShowsResource,'/theatre/<int:theatre_id>/shows',methods=['GET'])
    api.add_resource(CurrentUserCityResource,'/currentUserCity',methods=['GET'])
    api.add_resource(ShowsMovieCityResource,'/showsAtCity/<int:movie_id>/<string:city>',methods=['POST'])
if __name__ == "__main__":
    with app.app_context():
        db.create_all()
    
    app.run(host='0.0.0.0',port=int(os.environ.get('PORT', 5000)), debug=True)